# シフト演算

ビットを左右にずらして、かけ算やわり算を行う計算方法。

ビット列をn個左にずらすと元の数の2^n倍になる :dog:

ビット列をn個右にずらすと元の数の2^-n倍(1/2^n倍)になる :dog:

`0000 0110(6)`を左に2個ずらすと... `0001 1000(24)`になっている(6x2^2)

シフト演算には大きく以下の2種類がある。

- 論理シフト : 正負を考慮しない(符号ビットを考慮しない)
- 算術シフト : 正負を考慮する(符号ビットを考慮する)

## 論理シフト

- ビット列からはみ出たビットを捨てる
- 空いたビットには`0`を入れる

論理シフトはビット列の先頭にある符号ビットを特別扱いしないため、正負のあるビット列に論理シフトをすると正しい結果が得られない。

## 算術シフト

こちらは、正負を正しく計算するために符号ビットを特別扱いする。

- 符号ビットは固定したまま、ビット列を左右にずらす
- ビット列からはみ出たビットを捨てる
- 左方向にずらした場合は、空いたビットに`0`を入れる
- 右方向にずらした場合は、空いたビットに`符号ビットと同じ数`を入れる

### -12をずらしてみる

- `0000 1100`(12)
- `1111 0011`(ビット反転)
- `1111 0100`(1を足す => これが2の補数表現で表した-12)

- `符号ビットは固定したまま`左方向に2ビットずらす(空いたビットには0) : `1101 0000` => -48(-12の2^2倍)
- 同じく右方向に2ビットずらす(空いたビットには符号ビットと同じ1) : `1111 1101`
- `1111 1101`から1引いてビット反転 => `0000 0011`(3)なので、`1111 1101`は-3(-12の2^-2倍)

## シフト演算と足し算の組み合わせ

シフト演算では、2のべき乗分しかかけたり、わったりできない。

=> 9倍とかはできない

でも、足し算を組み合わせたらシフト演算も活用できる :dog:

`9x = 8x + x` みたいにする。

```
# 2進数11を9倍する (3x9=27になるはず)
0000 0011 を8倍(8倍は2^3倍)するので、左に3ビットずらす => 0001 1000(これで8倍)
これに元の数の11を足す => 0001 1011(27になった)

# 9x = 8x + x
3 x 9 => 3 x 8 + 3 => 24 + 3 => 27 これやったのと同じ
```

## ビット入れ替え(例題)

16bit : `11110000 00001111` => `00001111 11110000`

入れ替え後の下位8bitは、入れ替え前上位8bitを右へ8bitシフトしている。

- 右へ1bitシフト : 1/2
- 右へ2bitシフト : 1/4
- 右へ3bitシフト : 1/8
- 右へ8bitシフト : 1/2^8 (1/256)

同様に、入れ替え後の上位8bitは、入れ替え前の下位8bitを左へ8btiシフトしている。

入れ替え前の下位8bitを求めるには、もとの16bitを256で割った余りと同じ。(ここが注意)

これを左に8bitシフトさせるために256(2^8)をかける。

これらを足す。

```
11110000 00001111 / 2^8 = 00000000 11110000 # 右8bitシフトで下位8bitできた(1)

11110000 00001111 % 2^8 = 00000000 00001111 # いったんもとの下位8bitだけとりだす

00000000 00001111 x 2^8 = 00001111 00000000 # 左8bitで上位にもっていく(2)

00000000 11110000 + 00001111 00000000 = 00001111 11110000 # (1)と(2)を足す
```

