# 正規表現を使ったテキスト検索

正規表現はシェルのメタキャラクタ同様、任意の文字列パターンを表すための表記方法

ファイル内の文字列を柔軟かつ強力に検索することができる

シェルのメタキャラクタと混合しないように注意が必要！

## 1 正規表現(Regular Expression)

正規表現とシェルのメタキャラクタは同じ文字でも意味が異なるので注意が必要

### 文字

正規表現の中にある文字は、文字そのものを表す

`abc`であれば文字列`abc`をそのまま表している

### 任意の1文字

任意の1文字を表すには「.(ピリオド)」を使用する

`a..d`は`abcd`や`a12d`を表す

### 文字クラス

一連の文字集合を表すには`[]`でくくる => これが`文字クラス`

`[123]`は`1`, `2`, `3`のいずれか1文字を表す

`c[au]t`であれば、`cat`または`cut`を表す

`-`を使用して範囲を指定することも可能

`a[5-7]b`であれば、`a5b`, `a6b`, `a7b`のいずれか表す

`[a-z]`はアルファベット小文字いずれか、`[A-Z]`はアルファベット大文字いずれかを表し、

`[a-zA-Z]`は大文字小文字を問わずアルファベット1文字を表し、`[0-9]`は数字を表す

`^(ハット)`が先頭に置かれている場合は`～以外`を表す

`[^abc]`なら`aでもbでもcでもない1文字`という意味になる

### 行頭と行末

`^`は先頭を、`$`は行末を表す

`^a`は`行頭にあるa`を表し、`a$`は`行末にあるa`を表す

`^$`は`行頭と行末の間に何もないもの`を意味し、つまり`空行(改行のみ)`を意味している

=> `^`や`$`のように文字列内の位置にマッチする正規表現を`アンカー`という

### 繰り返し

直前の文字の0回以上の繰り返しは`*`を使用する

`ab*z`は`az`, `abz`, `abbz`などを表す(繰り返しが0回のazにもマッチ)

拡張正規表現であれば、`{n}`を使用すると、直前の文字のn回以上の繰り返しを表す

`[a-z]{5}`はアルファベット小文字の5回繰り返し(5文字)を表す

600-8853のような郵便番号は`[0-9]{3}-[0-9]{4}`で表すことが可能

### 特殊文字

正規表現に用いられるメタキャラクタを文字として扱いたい場合、

文字の前に`\(バックスラッシュ)`をつけることで正規表現としての意味を打ち消すことができる

`a\*`は`a*`という文字列そのものを表す(有効なのが直後の1文字だけ)

### 主な正規表現

| メタキャラクタ | 説明                                                                             |
|----------------|----------------------------------------------------------------------------------|
| .              | 任意の一文字                                                                     |
| *              | 直前の文字の0回以上の繰り返し                                                    |
| []             | []内の文字のいずれかの1文字(-: 範囲を指定 / ^: 先頭にあるときは「〜以外」を表す) |
| []             | [0-9]は数字, [a-z]はアルファベット小文字, [A-Z]は大文字, [a-zA-Z]で大文字小文字  |
| ^              | 行頭                                                                             |
| $              | 行末                                                                             |
| \              | 次にくる文字をメタキャラクタではなく通常の文字といて処理                         |

## 2 grep

ファイルテキストストリーム中に、正規表現によって表される検索文字列があるかを調べることができる

引数にファイルを指定した場合、そのファイルの中で検索パターンにマッチした文字列が含まれる行を表示する

=> ファイルは複数指定することが可能

```
grep [オプション] 検索パターン [ファイル名]

grep [オプション] [-f ファイル名] [ファイル名]
```

| オプション | 説明                               |
|------------|------------------------------------|
| -c         | マッチした行の行数だけを表示       |
| -f         | 検索パターンをファイルから読み込む |
| -i         | 大文字小文字を区別しない           |
| -n         | 行番号も表示                       |
| -v         | マッチしない行を表示               |
| -E         | 拡張正規表現を使用(egrep)          |

```
# 大文字小文字の区別を無視
grep -i ab sample.txt
```

=> ab, Ab, aB, ABのいずれかがマッチする

```
# パターンがマッチしない行を表示
grep -v '^#' sample.txt
```

=> 行頭が`#`で始まる行(コメント行)以外がマッチ

=> ''で検索パターンをかこむことで、シェルがメタキャラクタを解釈することを防ぐ

```
# 指定したファイルの内容を検索パターンとして読込む
grep -f regexp sample.txt
```

=> `regexp`ファイルを検索パターンとして読み込んでいる

### 拡張正規表現 / grep -E / egrep

拡張正規表現を使用するには`grep -E`もしくは`egrep`コマンドを使用する

| メタキャラクタ | 説明                                 |
|----------------|--------------------------------------|
| +              | 直前の文字の1回以上の繰り返し        |
| ?              | 直前の文字の0回もしくは1回の繰り返し |
| \|             | 左右のいずれかの記述にマッチ         |
| {n}            | 直前の文字のn回の繰り返し            |
| {n,m}          | 直前の文字のn回からm回の繰り返し     |

```
# 22/tcpもしくは53/tcpが含まれる行を検索
egrep '\s(22|53)/tcp' /etc/services
```
- `\s`: 空白文字(スペース、タブ)
- `(22|53)`: 22または53
- `/tcp`: /tcpという文字列

=> 空白文字の後に「22」または「53」、続いて「/tcp」と記述された部分を検索する

### fgrep

検索パターンに正規表現を使わない場合は`fgrep`コマンドを使用する

```
# .* という文字列で検索(正規表現でない)
fgrep '.*' sample.txt

# grepで同じことするなら \ でエスケープ
grep '\.\*' sample.txt
```

## 3 sed

sed(Streme Editor)コマンドはテキストストリートに対して編集を行う

編集する内容をコマンドやスクリプトで指示しておき、その指示に基づいて編集

=> 標準出力に編集結果を書き出す

```
# 指定したファイルに対してコマンドを適用(ファイル指定なしの場合、標準入力から読込まれる)
sed [オプション] コマンド [ファイル]

# 複数のコマンドを適用(コマンドごとに-eオプションを使用する)
sed [オプション] -e コマンド1 [-e コマンド2 ...] [ファイル]

# コマンドを記述したスクリプトファイルを指定
sed [オプション] -f スクリプト [ファイル]
```

| オプション  | 説明                                       |
|-------------|--------------------------------------------|
| -f ファイル | コマンドが書かれたスクリプトファイルを指定 |
| -i          | 処理した内容でファイルを上書き             |

| コマンド    | 説明                                                            |
|-------------|-----------------------------------------------------------------|
| d           | マッチした行を削除                                              |
| s           | パターンに基づいて置換 => gスイッチを使うとマッチ箇所を全て置換 |
| y           | 文字を変換                                                      |

### dコマンド

次の例では、file1.txtファイルの1行目から5行目までをdコマンドで削除し、file2.txtファイルに保存する

リダイレクトを使用して保存しているところに注意(sedコマンドでは(-iオプションを使用しないと)元ファイルを変更しない)

```
sed '1,5d' file1.txt > file2.txt
```

### sコマンド

検索パターンにマッチする部分を置換パターンに置き換えるには、`s/検索パターン/置換パターン/`を指定する

次の例ではlinuxという文字を大文字のLINUXに変更している

```
sed s/linux/LINUX/ file1.txt
```

sコマンドでは、検索パターンにマッチする部分が1行に複数あっても、最初にマッチした部分だけを置換する

マッチする部分すべてを置換するには、`gスイッチ`を最後に記述する

```
sed s/linux/LINUX/g file1.txt
```

次の例では、/etc/passwdファイルの1行目から5行目までの行頭に`>`記号を加える

コマンド部分を''で囲むのは、シェルが`>`記号をリダイレクト記号と解釈しないようにするため

```
sed '1,5s/^/>/' /etc/passwd
```

### yコマンド

`y/検索文字/置換文字/`を使用すると、ストリーム中に検索文字にマッチする文字があった場合、

その文字を置換文字の同じ位置の文字に置き換える

次の例では「A」を「1」に、「B」を「2」に、「C」を「3」に置き換える

=> 検索文字と置換文字は同じ長さを指定する必要がある

```
sed y/ABC/123/ sample.txt
```

### -f: コマンド記述ファイル読み込み

コマンドは、スクリプトファイルにまとめて記述しておくことができ、`-f`オプションで読込む

```
cat sedscripts
1,10s/linux/Linux/g

sed -f sedscripts file1.txt
```

