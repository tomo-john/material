# シェルスクリプト(Bash)

## シェルの基本概念
- シェルとは: ユーザーとOSの間のインターフェース

  コマンドを入力して実行したり、スクリプトを実行したりするための環境を提供

- 代表的なシェル: Linuxではbashが最も一般的

  sh(Bourne Shell), ksh(Korn Shell), zsh(Z Shell)などがある

## 環境変数
- 環境変数とは: システム全体やシェルの動作に影響を与える変数
- 環境変数の確認: `echo`コマンドと`$`で環境変数の値を表示可能

  → `echo $PATH`: `PATH`環境変数の内容を表示

## シェルのカスタマイズ
- プロンプトの変更: シェルプロンプトの表示形式をカスタマイズすることが可能

  → `PS1`環境変数を変更することで、プロンプトの表示内容を変更できる

- 設定ファイル: `~/.bashrc`, `~/.bash_profile`などの設定ファイルを編集することで

  自動で実行されるコマンドやコマンド設定を指定できる

## 基本的なスクリプトの実行
- スクリプトの実行: シェルスクリプトを実行するには、スクリプトファイルに実行権の付与が必要

  ```
  chmod +x script.sh
  ```

## 変数
シェルスクリプトでは変数を使って値を一時的に保存したり、操作に利用することが可能
- 変数の宣言: 変数名の後に`=`で値を指定(`=`の前後にスペースは入れない!)

  ```
  my_var="john"
  ```

- 変数の参照: 変数名の前に`$`をつけることで変数の値を参照できる

  ```
  echo $my_var # 出力: john
  ```

- 数値計算: 変数に数値を代入して計算も可能(数値計算は`$((...))`で囲むことで行う)

  ```
  num1=2
  num2=8
  sum=$((num1 + num2))
  echo $sum # 出力: 10
  ```

## 環境変数の設定
環境変数を設定してシェルやシステムに反映させるには`export`コマンドを使用
```
export MY_ENV_VAR="sample john"
echo $MY_ENV_VAR # 出力: sample john
```

`~/.bashrc`や`~/.bashprofile`に環境変数を記述することで、次回シェル起動時にも同じ環境変数を利用できる
```
echo 'export DOG_NAME="john"' >> ~/.bashrc
source ~/.bashrc # 即座に反映
```

## 条件分岐
シェルスクリプトでは`if`や`case`を使用するのが一般的

`if文`
```
if [条件式]; then
  # 真の時の実行文
elif [別の条件式]; then
  # 別の条件が真の時の実行文
else
  # すべての条件が偽の時の実行文
fi
```

`例`
```
# numが10以上かどうか
num=28

if [$num -ge 10]; then
  echo "10以上です"
else
  echo "10未満です"
fi
```

`主な条件式1(整数)`
- `-eq`: 等しい
- `-ne`: 等しくない
- `-lt`: より小さい
- `-le`: 以下
- `-gt`: より大きい
- `-ge`: 以上
- `-z`: 文字列が空
- `-n`: 文字列が空でない

`主な条件式2(文字列)`
- `=`: 等しい
- `!=`: 等しくない
- `<`: 文字列が辞書順で小さい `[[...]]内のみ使用可能`
- `>`: 文字列が辞書順で大きい `[[...]]内のみ使用可能`

`case文`
```
case 変数 in
  値1)
    # 値1に一致する時の式
    ;;
  値2)
    # 値2に一致する時の式
  *)
    # どれにも一致しない場合の式
    ;;
esac
```

`例`
```
# $animalの値に応じて分岐
animal="dog"

case $animal in
  "bear")
    echo "くま"
    ;;
  "dog")
    echo "いぬ"
    ;;
  *)
    echo "未知の生物"
    ;;
esac
```

## ループ構造
Bashでは`for`, `while`, `until`の3つのループが基本的な構文

`for`: 指定したリストや範囲に対して繰り返し処理を行う
```
for 変数名 in リスト; do
  # 各要素に対して実行する処理
done
```
```
for i in 1 2 3 4 5; do
  echo "number is $i"
done
```
数値範囲を指定する場合は`{開始..終了}`
```
for i in {1..5}; do
  echo "number is $i"
done
```

`while`: 指定した条件が真の間、処理を繰り返す
```
while [ 条件式 ]; do
  # 条件が真の間、実行する処理
done
```

```
i=1
while [ $i -le 5 ]; do
  echo "number is $i"
  i=$(($i + 1))
done
```

`until`: `while`と逆に指定した条件が偽の間、処理を繰り返す

```
until [ 条件式 ]; do
  # 条件が偽の間、実行する処理
done
```

```
i=1
until [ $i -gt 5 ]; do
  echo "number is $i"
  i=$((i + 1))
done
```

ループの制御コマンドには`break`, `continue`がある
- `break`: ループを中断して抜ける
- `continue`: 現在の反復をスキップし、次の反復へ進む

```
for i in {1..5}; do
  if [ $i -eq 3 ]; then
    break
  fi
  echo "john $i"
done
```

## 関数
関数は特定の処理をまとめて再利用できるようにするための機能

`関数の定義`

```
function_name(){
  # 関数内の処理
}
```
もしくは`function`キーワードを使用して定義も可能
```
function function_name{
  # 関数内の処理
}
```

`関数の呼び出し`

関数名を記述し、必要に応じて引数を指定する
```
greet "john"
```

`引数の取り扱い`

関数内で受け取った引数は、`$1`, `$2`, ...でアクセスが可能

`$0`はスクリプト名を指し、すべての引数は`$@`(全引数のリスト)や`$#`(引数の数)で取得が可能
```
test(){
  echo "合計: $(($1 + $2 + $3))"
  echo "全引数: $@"
  echo "引数の数: $#"
  echo "スクリプト名: $0"
}
test 1 2 3
```

`戻り値`

`return`コマンドを使用して戻りを設定することが可能(戻り値は`0～255`の範囲の整数

```
is_even(){
  if [ $(($1 % 2)) -eq 0 ]; then
    return 0 # even
  else
    return 1 # odd
  fi
}

is_even 28
if [ $? -eq 0 ]; then
  echo "even john"
else
  echo "odd john"
fi
```

`関数のスコープ`

関数内で定義された変数は、その関数のスコープ内でのみ有効

グローバル変数を使用する場合は関数外で変数を定義する必要がある

```
global_var="john"

dog(){
  echo "$global_var: $1"
}

dog "bow"
```

## スクリプトのデバッグ

`デバッグの基本的な方法`

1. `set -x`と`set +x`

デバッグのためにスクリプト内のコマンドが実行される際に表示を行うことが可能

`set -x`を使うと実行されるコマンドが表示され、その後に出力が表示される

デバッグを終了するには`set +x`を使用する

```
#!/bin/bash
set -x # デバッグ開始
echo "デバッグ中..."
animal="dog"
echo "$animal"
set +x # デバッグ終了
```

2. `set -e`

コマンドが失敗(非ゼロの終了ステータス)した場合にスクリプトが即座に終了する

=> これにより、エラーが発生した箇所を特定しやすくなる

```
set -e # エラーが発生したらスクリプトを終了
echo "処理中..."
johnjohn # 意図的にエラー => スクリプトが終了
echo "これは表示されない"
```

3. `trap`コマンド

スクリプトがエラーを発生させたときに特定のコマンドを実行できる

=> スクリプト終了時にクリーンアップ処理を行いたい場合に便利

```shell
#!/bin/bash

trap 'echo "エラーが発生しました"; exit 1' ERR

echo "処理中..."
johnjohn # エラーが発生するとtrapが発動
echo "これは表示されない"
```

`スクリプトの文法エラーの確認`

1. `bash -n`

スクリプトを実行せずに文法エラーを確認することができる(構文チェックが可能)

```
bash -n script.sh
```

2. エラーメッセージ

スクリプト実行後にエラーが発生した場合は、エラーメッセージをよく確認することが重要

Bashは通常、エラーの原因となったコマンドや、その行番号を表示してくれる

3. ログファイルの作成

デバッグの際に、スクリプトの出力をログファイルに保存することで、後から詳細を確認することが可能

```
./script.sh > output.log 2>&1
```
- `2>`: 標準エラー出力をリダイレクトする指示
- `&1`: 標準出力が指すファイルディスクプリンタに標準エラー出力をリダイレクト
- `2>&1`: 標準エラー出力を標準出力の行先に合わせる => 標準エラー出力を標準出力にリダイレクト

## スクリプトの実行

1. インタプリタを指定して実行

スクリプトの先頭にシバン(shebang)を記述することで、どのインタプリタを使用してスクリプトを実行するか指定が可能

```shell
#!/bin/bash
```
この行をスクリプトの先頭行に追加することで`./script.sh`のように直接実行が可能(実行権の付与は必要)

2. Bashを使用して実行

シバンを指定していないスクリプトや、ファイルの実行権限が設定されていない場合は、`bash`コマンドでスクリプトの実行が可能

```
bash script.sh
```

3. `source`または`または`.`で実行

スクリプトを現在のシェル環境で実行したい場合、`source`, `.`で実行することが可能

=> スクリプト内で定義された変数や関数が現在のシェルに影響を与える

```
source script.sh
. script.sh
```

## 入力と出力のリダイレクション
リダイレクションは、コマンドやスクリプトの入力と出力を操作するための重要な機能

これにより、標準出力や標準エラー出力をファイルに保存したり、ファイルから入力を受け取ることができる

1. 標準出力のリダイレクション

`>`

```
echo "Hello, john" > output.txt
```
標準出力をファイルにリダイレクトしている

この時、指定したファイルが存在する場合は、上書きされる

`>>`

標準出力をファイルに追加することができる

指定したファイルが存在する場合、ファイルの末尾に新しい出力が追加される

2. 標準エラーのリダイレクション

```
error_command 2> error.log
```
標準エラー出力をファイルにリダイレクトしている

=> エラーメッセージを指定したファイルに保存することが可能

3. 標準出力と標準エラー出力の同時リダイレクション

```
command > output.log 2>&1
```
エラーメッセージも通常の出力と同じファイルに保存が可能

4. 入力のリダイレクション

```
sort < unsorted.txt
```
ファイルからの入力を受け取るには`<`を使用

これにより、ファイルの内容をコマンドの標準入力として使用することができる

5. ヒアドキュメント

ヒアドキュメント(Here Document)を使用することで、スクリプト内に直接入力を埋め込むことが可能

```
cat <<EOF
このテキストは
ヒアドキュメントによって
出力されます
EOF
```
=> `cat`コマンドがヒアドキュメントの内容(EOF～EOF間の部分)を出力する

## コマンドの実行制御

1. `&&`演算子

左側のコマンドが成功(終了ステータスが0)の場合、右側のコマンドを実行

```
touch test.txt && chmod 751 test.txt
```

2. `||`演算子

左側のコマンドが失敗(終了ステータスが1)の場合、右側のコマンドを実行

```
cd john || echo "そんなディレクトリはありません"
```
3. 複数のコマンドを組み合わせる

```
cmd1 && cmd2 || cmd3
```
- cmd1が成功するとcmd2
- cmd1, cmd2のいずれかが失敗するとcmd3

4. グループ化

- `{}`で複数のコマンドをグループ化することができる
- `{}`の前後にはスペースを入れる必要があり、各コマンドは`;`で区切る
- `;`左側のコマンドの成功失敗にかかわらずに必ず実行される

```
{ mkdir test_dir && cd test_dir; } || { echo "ディレクトリの作成または移動に失敗しました。"; exit 1; }
```

