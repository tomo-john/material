# ソート

代表的なソートアルゴリズム。

データを特定の順序(昇順や降順)に並べ替えるための手法。

それぞれのアルゴリズムには、得意な状況や特徴がある。

## バブルソート(Bubble Sort)

隣接する要素を比較し、順序が逆であれば交換することを繰り返す。

これにより配列の端から大きい(または小さい)値が泡のように浮かび上がってくる様子からこの名前がついている。

特徴:

- 実装が簡単で初心者向けのアルゴリズム
- 効率は悪く、要素数が増えると処理時間が急激に増大
- `O(n^2)`

## クイックソート(Quick Sort)

配列の中から基準となる要素(ピボット)を1つ選び、ピボットより小さい要素を左に、大きい要素を右側に集める。

その後、左側と右側の配列に対して再帰的に同じ処理を繰り返す。

特徴:

- 非常に高速なアルゴリズムで、実用的なソートアルゴリズムとして広く利用されている
- `O(n log n)`

## シェルソート(Shell Sort)

離れた位置にある要素を比較して交換することから始めるソート。

最初に大きな間隔(ギャップ)を設定し、その間隔で要素を比較・交換するソートを繰り返す。

徐々に間隔を小さくしていき、最後は間隔1の挿入ソート(隣接要素の比較)で完了。

- バブルソートや挿入ソートの改良版
- 離れた要素の交換ができるため、データの並び替えが大きく進む
- クイックソートに近い高速なソートだが、安定ソートではない(同値の要素の順序が保持されない)

## ヒープソート(Heap Sort)

与えられた配列をヒープと呼ばれる特殊な二分木構造に変換。

ヒープでは、親ノードが子ノードより常に大きい(または小さい)という性質を持っている。

この性質を利用して、配列の先頭にある最大値(または最小値)を末尾に移動させ、残りの要素で再度ヒープを再構築することを繰り返す。

特徴:

- 最悪の場合でも安定した計算量(`O(n log n)`)
- 再帰呼び出しが不要なため、使用するメモリ量が少ない

# 計算量(時間計算量)について

- n : ソートするデータの要素数
- O(n^2) : データ量が2倍になると、処理時間は約4倍(2^2倍)　=> バブルソートなど
- O(nlogn): データ量が2倍になると、処理時間は約2.3倍(2xlog 2) => クイックソートやヒープソートなど

