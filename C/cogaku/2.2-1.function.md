# 関数

## 1.関数とは
C言語は複数の関数で構成される

ある特定の機能や目的を実現するためのロジックのかたまりを1つの関数として定義する

プログラムが起動されると最初にmain関数が処理される

その中で使用されている関数が処理順序に従い呼び出される

main関数は必須であり、関数名を変えることはできない

関数には処理した値を呼び出し元へ返すものと返さないものがあり、定義の仕方で変わってくる

## 2.関数の宣言
関数宣言時は、以下のように宣言し、プロトタイプ宣言と呼ばれることが多い
```c
return型 関数名(引数型1, 引数型2, ... , 引数型n);

int function1(char, long);
```
return型は関数が処理した結果を、データとして呼び出し元に返す場合のデータ型を示す

関数名には任意の名称をつけることができるが、変数名と同様に重複した名称や予約語はつけることができない

引数型は関数が処理をするのに必要なデータを複数の引数という形で渡すことができ、そのデータ型を示す

`void`型とは空のデータ型を示す

=> return型にこれを指定した場合、関数からの戻り値がないことを示す
```c
// 引数データがなく、戻り値もないことを示す
void Function1(void);

// 省略も可能
void Function1();
```

## 3.関数の記述
```c
return型 関数名(引数型1, 引数型2, ..., 引数型n)
  {
    // ロジックを記述
    // ...

    return 定数や変数や式;
  }
```
return文はその関数を終わらせる制御文 => 関数内のロジックの最後か途中に記述が可能

retrunの後の定数や変数や式は、その値や結果を呼び出し元に返す

return型にvoid型を指定いる場合、retrunだけの記述になる

関数が引き取った引数は、その関数の中で変数として利用することが可能(`ローカル変数`)

```c
int func_Add(int nparam1, int nparam2)
  {
    int nadd;
    nadd = nparam1 + nparam2;
    return nadd;
  }
```

## 4.関数の呼び出し
```c
リターン受け変数 = 関数名(引数1, 引数2, ...)
```
リターン受け変数は呼び出す関数と同じデータ型でなければならない

呼び出す関数のリターン型がvoidの場合、リターン受け変数はない

```c
int Function1(char, long);

int nrtn;
char c1;
long l1;

nrtn = Function1(c1, l1);
```
Function1にc1とl1の変数の内容を渡し、nrtnにはFunction1の中のreturn文で記述された値が代入される

呼び出す関数のリターン型がvoid型の場合や、リターン値を必要としない場合、リターン受け変数は必要ない

呼び出す関数に引数がない(voidが宣言されている)場合、`nrtn = Function();`のように記述する

## 5.プロトタイプ宣言を省略する方法
関数を記述する前にプロトタイプ宣言をしなければならないが、これを省略することができる

コンパイラは、ソースプログラムを先頭から順番に解析していく

このとき、関数に関しては
- 1: プロトタイプ宣言から関数を知る
- 2: 関数の定義から知る
の2通りの判断をする

プロトタイプ宣言の記述はここまで記載した内容

プロトタイプ宣言を省略する方法は2の方を利用する
```c
#include <stdio.h>

void Function1(void){
  printf("john\n");
}

int main(){
  Function1();
}

```
main関数でFunction1が呼び出されているが、プロトタイプ宣言がなくても、

Function1が先に解析されているため、コンパイラはその解析結果を使用する

このような記述方法では`呼び出し、呼び出される関数が同じソースプログラムファイル内に存在していなけらばならない`

## 6.データの渡し方

### 1: 数値データ
数値データは`値による呼び出し(Call by value)`という直接データそのものが渡される
```c
int main(){
  int n1;
  n1 = 10;
  Function(n1);
}

int Function(int na){
  ...
}
```
のようにFunction(n1)が呼び出されたときに`n1 => na`と変数n1の内容がnaに代入される

=> 受け取った引数naには10が代入される

### 2: 配列データ
文字列や配列を渡す場合は、`アドレスによる呼び出し(Call by address)`というデータのアドレスが渡される
```c
int main(){
  int n1[10];
  Function(n1);
}

int Function(int *na){
  ...
}
```
のようにFunction(n1)が呼び出されたときに配列変数n1のアドレスがnaに代入される

文字列も配列なので、関数に渡すとアドレスが渡される

### 違い
値渡し(call by value)は関数内でその値を変更しても元の値は変わらない

アドレス渡し(call by address)は配列の最初の要素のアドレスが渡される

=> 関数内で配列や文字列を変更すると元の配列や文字列が変更される

### sample
```c
#include <stdio.h>

int Func_plus(int, int);
void Func_disp(int);

int main(){
  int n1, n2, n3;

  printf("1番目の数値: ");
  scanf("%d", &n1);
  printf("2番目の数値: ");
  scanf("%d", &n2);

  n3 = Func_plus(n1, n2);

  Func_disp(n3);
}

int Func_plus(int n1, int n2){
  return n1 + n2;
}

void Func_disp(int n1){
  printf("\n2つの数値を加算すると %d です", n1);
}
```

