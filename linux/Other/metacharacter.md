# metacharacter

## シェルと正規表現での違い

| meta | shell                          | regex                           |
|------|--------------------------------|---------------------------------|
| `*`  | 任意の文字列(0文字以上)        | 直前の文字が0回以上繰り返される | 
| `?`  | 任意の1文字                    | 直前の文字の0回または1回の出現  |
| `{}` | 選択肢をグループ化             | 繰り返し回数を指定              |
| `()` | サブシェルの実行               | グループ化                      |
| `.`  | 特に意味はない(文字として解釈) | 任意の1文字                     |
| `$`  | 変数展開                       | 行の末尾                        |
| `^`  | 特に意味はない                 | 行の先頭                        |

シェルで正規表現を使用する場合は、正規表現の文字がシェルで解釈されないようにするため、

`"`や`'`で囲む、または`\`でエスケープする必要がある。

- 例: `grep "a.*b"`とすると正規表現として解釈される

### *

シェルでの解釈: 任意の文字列(0文字以上)

例: `ls *.txt`

=> 拡張子が`.txt`のすべてのファイルを表示(file.txt, file1.txt, a.txtなど)

正規表現での解釈: 直前の文字の0回以上の繰り返し

例: `grep "a*b" sample.txt`

=> sample.txt内でaが0回以上続いた後にbが来る行を検索(b, ab, aaaaab)

### ?

シェルでの解釈: 任意の1文字

例: `ls file?.txt`

=> file1.txt, fileA.txtのように、fileの後に任意の1文字が続く.txtファイルを表示

正規表現での解釈: 直前の文字の0回または1回の出現

例: `grep "colou?r" sample.txt`

=> sample.txt内でcolorまたはcolourにマッチする行を検索

### {}

シェルでの解釈: 選択肢を列挙して展開

例: `echo {red,green,blue}`

=> 出力は red green blue

正規表現での解釈: 繰り返し回数を指定

例: `grep "a{2,4}" sample.txt`

=> sample.txt内でaが2回から4回続く部分にマッチ(aa, aaa, aaaa)

### ()

シェルでの解釈: サブシェルの実行

例: `(cd /tmp; ls)`

=> 一時的に/tmpディレクトリに移動し、その中のファイル一覧を表示

正規表現での解釈: グループ化

例: `grep -E "(foo|bar)" sample.txt`

=> sample.txt内でfooまたはbarにマッチする行を検索

### |

シェルでの解釈: パイプ

例: `ls | grep txt`

=> lsの出力からtxtを含む行をフィルタリング

正規表現での解釈: OR条件(AまたはB)

例: `grep -E "(foo|bar)"` sample.txt

=> sample.txt内でfooまたはbarにマッチする行を検索

### .

シェルでの解釈: 特に意味を持たず、文字として解釈

正規表現での解釈: 任意の1文字

例: `grep "a.b" sample.txt`

=> sample.txt内でaとbの間に任意の1文字がある部分(acb, a1b, aaaなど)

### $

シェルでの解釈: 変数展開

正規表現での解釈: 行の末尾

例: `grep "end$" sample.txt`

=> sample.txt内で行末がendで終わる行を検索

### ^

シェルでの解釈: 特に意味を持たず、文字として解釈

正規表現での解釈: 行の先頭

例: `grep "^start" sample.txt`

=> sample.txt内で行の先頭がstartで始まる行を検索

